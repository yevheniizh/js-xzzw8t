<label style="color: white;">Play-pause toggler
  <input type="checkbox" disabled id="play-pause-toggler" />
</label>

<label style="color: white;">Audio enhancer toggler
  <input type="checkbox" disabled id="audio-enhancer-toggler" />
</label>

<div style="width: 200px; height: 40px; background-color: rgba(100, 100, 200, 0.5);" id="audio-progress-bar-container"></div>

<!-- To be migrated to the Webflow -->
<style>
  #play-pause-toggler + span, #audio-enhancer-toggler + span {
    user-select: none;
  }
  #audio-progress-bar-container {
    display: flex;
    align-items: center;
    justify-content: center;
  }
  input[type='range'] {
    overflow: hidden;
    width: 200px;
    margin: 0 10px;
    -webkit-appearance: none;
    background-color: rgb(214 215 216);
    border-radius: 2.5px;
  }
  input[type='range']::-webkit-slider-runnable-track {
    height: 5px;
    -webkit-appearance: none;
    margin-top: -1px;
    cursor: pointer;
  }
  input[type='range']::-webkit-slider-thumb {
    width: 5px;
    -webkit-appearance: none;
    height: 5px;
    background: transparent;
    box-shadow: -100px 0 0 100px rgb(139 115 239);
  }
  input[type="range"]::-moz-range-progress {
    background-color: rgb(139 115 239); 
  }
  input[type="range"]::-moz-range-track {  
    background-color: rgb(214 215 216);
  }
  input[type="range"]::-ms-fill-lower {
    background-color: rgb(139 115 239); 
  }
  input[type="range"]::-ms-fill-upper {  
    background-color: rgb(214 215 216);
  }
</style>

<canvas id="webgl" style="position: absolute; inset: 0; z-index: -1"></canvas>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.156.1/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.156.1/examples/jsm/"
    }
  }
</script>

<script type="module">
  import * as THREE from 'three';
  import {RenderPass} from 'three/examples/jsm/postprocessing/RenderPass';
  import {EffectComposer} from 'three/examples/jsm/postprocessing/EffectComposer';
  import {UnrealBloomPass} from 'three/examples/jsm/postprocessing/UnrealBloomPass';
  import {RGBShiftShader} from "three/examples/jsm/shaders/RGBShiftShader";
  import {ShaderPass} from "three/examples/jsm/postprocessing/ShaderPass";

  const vertexShader = `
    varying vec2 vUv;
    varying vec3 vPosition;
    varying float x;
    varying float y;
    varying float z;
    uniform float[64] tAudioData;
    uniform float uTime;
    uniform float uWavesElevation;
    uniform float uWavesSpeed;
    varying float vElevation;
    void main() {
      vUv = uv;
      vPosition = position;

      x = abs(position.x);
      y = abs(position.y);

      float floor_x = round(x);
      float floor_y = round(y);

      z = sin(tAudioData[int(floor_x)] / 32.0 + tAudioData[int(floor_y)] / 32.0) * 0.75;

      float sin1 = sin((position.x + position.y) * 0.2 + uTime * uWavesSpeed);
      float sin2 = sin((position.x - position.y) * 0.2 + uTime * uWavesSpeed);
      float sin3 = sin((position.x + position.y) * -0.25 + uTime * uWavesSpeed);
      vec3 updatePosition = vec3(position.x, position.y, z);

      vec4 modelPosition = modelMatrix * vec4(updatePosition, 1.0);

      float elevation = sin1 * sin2 * sin3 * uWavesElevation;

      modelPosition.y += elevation;

      gl_Position = projectionMatrix * viewMatrix * modelPosition;

      vElevation = elevation;
    }`;

  const fragmentShader = `
    varying vec2 vUv;
    varying vec3 vPosition;
    uniform float uTime;
    uniform float uStartTime; 
    const float duration = 2.0;
    const float delay = 0.0;
    uniform bool uAudioEnhanced;
    uniform bool uAudioEnhancedInitially;

    uniform vec3 uDepthColor;
    uniform vec3 uSurfaceColor;
    varying float vElevation;

    float sdfCircle(vec2 p, float r) {
      return length(p) - r;
    }

    void main() {
      float now = clamp((uTime - delay) / duration, 0.1, 1.0);
      float opacity = (1.0 - length(vPosition.xy / vec2(32.0))) * now;

      float speed = 0.5;
      float w = clamp((uTime-uStartTime) / speed, 0., 1.);
      w = mix(float(uAudioEnhancedInitially)*1.0-w, w, float(uAudioEnhanced));

      vec3 defaultColor = mix(uDepthColor, uSurfaceColor, vElevation * 2.5 + 0.75);
      vec3 enhancedColor = vec3(vUv, 1.0);

      float radius = 16.0 * w;
      float distance = sdfCircle( vPosition.xy, radius );

      vec3 gradientColor = mix(enhancedColor, defaultColor, step(radius, distance));
      
      gl_FragColor = vec4(gradientColor, opacity);
    }`;

  class Sketch {
    onMouseMove = (event) => {
      this.mouseX = event.clientX - this.width / 2;
      this.mouseY = event.clientY - this.height / 2;
    };

    onResize = () => {
      this.width = window.innerWidth;
      this.height = window.innerHeight;
      this.camera.aspect = this.width / this.height;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(this.width, this.height);
      this.renderer.setPixelRatio( Math.min( window.devicePixelRatio, 2 ) );
      this.composer.setSize(this.width, this.height);
      this.composer.setPixelRatio( Math.min( window.devicePixelRatio, 2 ) );
    };

    constructor() {
      const cdn = 'https://cdn.jsdelivr.net/gh/yevheniizh/js-xzzw8t@progress-bar';
      this.hrefFix = cdn + "/Magic-Audio-FIX.mp3";
      this.hrefRaw = cdn + "/Magic-Audio-RAW.mp3";

      this.canvas = document.getElementById('webgl');
      this.playPauseToggler = document.getElementById('play-pause-toggler');
      this.audioEnhancerToggler = document.getElementById('audio-enhancer-toggler');
      this.audioProgressBarContainer = document.getElementById('audio-progress-bar-container');

      this.audioProgressBar = document.createElement("input");
      this.audioProgressBar.setAttribute("type", "range");
      this.audioProgressBar.setAttribute("disable", "true");
      this.audioProgressBar.setAttribute("id", "audio-progress-bar");
      this.audioProgressBar.setAttribute("value", "0");

      this.audioProgressBarContainer.appendChild(this.audioProgressBar);

      this.width = window.innerWidth;
      this.height = window.innerHeight;

      this.target = new THREE.Vector3();
      this.mouseX = 0;
      this.mouseY = 0;

      this.scene = new THREE.Scene();

      this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
      this.renderer.setSize( this.width, this.height ); 
      this.renderer.setPixelRatio( Math.min( 2, window.devicePixelRatio ) );

      this.camera = new THREE.PerspectiveCamera( 85, this.width / this.height, 0.1, 1000 );

      this.composer = new EffectComposer( this.renderer );
      this.composer.setSize( window.innerWidth, window.innerHeight );
      this.composer.setPixelRatio( Math.min( window.devicePixelRatio, 2 ) );

      this.renderScene = new RenderPass( this.scene, this.camera );
      this.composer.addPass( this.renderScene );

      this.rgbShiftPass = new ShaderPass(RGBShiftShader);
      this.rgbShiftPass.uniforms["amount"].value = 0.0001;
      this.composer.addPass( this.rgbShiftPass );

      this.bloomPass = new UnrealBloomPass(
        new THREE.Vector2( window.innerWidth, window.innerHeight ),
        0.3, 5, 0,
      );
      this.bloomPass.enabled = false;
      this.composer.addPass( this.bloomPass );

      this.time = 0;

      this.fftSize = 512;

      this.setupMouseEvents();
      this.setupResize();
      this.setupPlayer();
      this.addObjects();
      this.render();
    }

    setupPlayer() {
      this.tracksReady = 0;
      this.trackRaw = this.prepareTrack( this.hrefRaw );
      this.trackFix = this.prepareTrack( this.hrefFix );
    }

    prepareTrack(href) {
      const listener = new THREE.AudioListener();
      const audio = new THREE.Audio( listener );
      this.context = audio.context;
      const mediaElement = new Audio( href );
      mediaElement.crossOrigin = "anonymous";
      mediaElement.loop = true;
      mediaElement.onloadeddata = () => {
        this.tracksReady = this.tracksReady + 1;
        if( this.tracksReady === 2 ) {
          this.onAllTracksLoad();
        };
      };

      audio.setMediaElementSource( mediaElement );
      const analizer = new THREE.AudioAnalyser( audio, this.fftSize );
      return ({ audio, analizer, mediaElement });
    }

    onAllTracksLoad() {
      this.playPauseToggler.disabled = false;
      this.audioEnhancerToggler.disabled = false;
      this.audioProgressBar.disabled = false;

      this.playPauseToggler.addEventListener( 'click', () => {
        if( this.context.state === 'suspended' ) {
          this.context.resume();
        
          this.activeTrack = this.trackRaw;
          this.inactiveTrack = this.trackFix;
          this.inactiveTrack.mediaElement.volume = 0;
        }

        if ( this.activeTrack.mediaElement?.paused ) {
          this.activeTrack.mediaElement.play();
          this.inactiveTrack.mediaElement.play();
        } else {
          this.activeTrack.mediaElement.pause();
          this.inactiveTrack.mediaElement.pause();
        }
      } );

      this.audioEnhancerToggler.addEventListener( 'click', () => {
        if ( this.audioEnhancerToggler.checked ) {
          this.activeTrack = this.trackFix;
          this.inactiveTrack = this.trackRaw;
          this.rgbShiftPass.enabled = false;
          this.bloomPass.enabled = true;
          this.material.uniforms.uAudioEnhanced.value = true;
          this.material.uniforms.uAudioEnhancedInitially.value = true;
        } else {
          this.activeTrack = this.trackRaw;
          this.inactiveTrack = this.trackFix;
          this.rgbShiftPass.enabled = true;
          this.bloomPass.enabled = false;
          this.material.uniforms.uAudioEnhanced.value = false;
        }

        this.activeTrack.mediaElement.volume = 0.5;
        this.inactiveTrack.mediaElement.volume = 0;
        this.material.uniforms.uStartTime.value = this.time;
      } );

      this.mouseDownOnSlider = false;

      this.trackFix.mediaElement.addEventListener("timeupdate", () => {
        if (!this.mouseDownOnSlider) {
          this.audioProgressBar.value = this.trackFix.mediaElement.currentTime / this.trackFix.mediaElement.duration * 100;
        }
      });
      this.audioProgressBar.addEventListener("change", () => {
        const pct = this.audioProgressBar.value / 100;
        this.trackFix.mediaElement.currentTime = (this.trackFix.mediaElement.duration || 0) * pct;
        this.trackRaw.mediaElement.currentTime = (this.trackFix.mediaElement.duration || 0) * pct;
      });
      this.audioProgressBar.addEventListener("mousedown", () => {
        this.mouseDownOnSlider = true;
      });
      this.audioProgressBar.addEventListener("mouseup", () => {
        this.mouseDownOnSlider = false;
      });
    }

    setupMouseEvents() {
      window.addEventListener('mousemove', this.onMouseMove);
    }

    setupResize() {
      window.addEventListener('resize', this.onResize);
    }

    addObjects() {
      this.geometry = new THREE.PlaneGeometry(64, 64, 64, 64);
      this.material = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uStartTime: { value: 0 },
          position: { value: 0 },
          uAudioEnhanced: { value: false },
          uAudioEnhancedInitially: { value: false },
          tAudioData: { value: new Uint8Array() },
          uWavesElevation: { value: 0.35 },
          uWavesSpeed: { value: 0.25 },
          uDepthColor: { value: new THREE.Color( 'grey' ) },
          uSurfaceColor: { value: new THREE.Color( 'white' ) },
      },
        vertexShader,
        fragmentShader,
        transparent: true,
        wireframe: true,
      });
      this.mesh = new THREE.Mesh(this.geometry, this.material);
      this.scene.add(this.mesh);

      this.mesh.scale.set(0.5, 0.25, 0.5);
      this.mesh.position.set(0, 2, -10);
      this.mesh.rotation.set(-(Math.PI / 3), 0, 0);
    }

    render() {
      this.time += 0.02;
      this.material.uniforms.uTime.value = this.time;

      if (this.activeTrack?.analizer) {
        this.activeTrack.analizer.getFrequencyData();
        this.material.uniforms.tAudioData.value = this.activeTrack.analizer.data;
      }

      this.target.x = (1 - this.mouseX) * 0.0001;
      this.target.y = (1 - this.mouseY) * 0.0001;
      this.camera.rotation.x += 0.025 * (this.target.y - this.camera.rotation.x);
      this.camera.rotation.y += 0.025 * (this.target.x - this.camera.rotation.y);

      this.composer.render();
      window.requestAnimationFrame(this.render.bind(this));
    }
  }

  new Sketch();
</script>